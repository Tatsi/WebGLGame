<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>WebGL Test Game</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script src='js/threextext/threex.text.js'></script>
		<!-- script src="js/threextext/fonts/<droi></droi>d/droid_serif_regular.typeface.js"></script -->
		<script src='js/threexloop/threex.loop.js'></script>
		<script src='js/threexkeyboardstate/threex.keyboardstate.js'></script>
		<script src="js/ocean/water-material.js"></script>
		<script>
			// Init scene
			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 75, 9 / 16, 0.1, 1000 );
			//var camera = new THREE.PerspectiveCamera(55.0, 9 / 16, 0.5, 3000000);
			// var camera = new THREE.PerspectiveCamera( 75, 0.5, 0.1, 1000 );
			//camera.position.set(1000, 500, -1500);
			//camera.lookAt(new THREE.Vector3(0, 0, 0));
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerHeight/16*9, window.innerHeight );
			//renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

			// Add keyboard state object
			var keyboard = new THREEx.KeyboardState();

			// Add game related constants
			var blockArrayWidth = 6;
			var blockArrayLength = 10;
			var jumpDuration = 10;
			var jump_height = 1.2;
			var blockDistance = 0.5; // The distance between cells (=logs) in 3D scene
			var spawnLogsInterval = 1.0;
			var nextSpawnIn = spawnLogsInterval;
			const BLOCK_ARRAY_LAST_INDEX = blockArrayWidth - 1;

			// Add game related variables
			var action = "";
			var playerPositionIndexX = 3; // Between 0 and 5
			var playerPositionIndexY = 0; // Between 0 and 9
			var actionDuration = 0;
			var flowSpeed = 0.002;
			var lastRouteBlockIndex = playerPositionIndexX;
			var blocks = new Array(blockArrayLength);
			var blockObjects = new Array(blockArrayLength);

			blocks[0] = [false, false, false, false, false, false];
			blocks[0][playerPositionIndexX] = true;
			console.log(blocks[0]);
			for (var i = 1; i < blockArrayLength; i++) {
				blocks[i] = createRow();
				blockObjects[i] = createBlockObjectRow(blocks[i], i);
				console.log(blocks[i]);
			}

			// Add a player
			var geometry = new THREE.BoxGeometry( blockDistance, blockDistance, blockDistance );
			var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
			var player = new THREE.Mesh( geometry, material );
			var playerInitialY = -3;
			player.position.y = playerInitialY;
			scene.add( player );

			// Add light
			var directionalLight = new THREE.DirectionalLight(0xffff55, 1);
			directionalLight.position.set(0, 4, 0);
			//directionalLight.position.set(-600, 300, 600);
			scene.add(directionalLight);

			// Add water
			var loader = new THREE.TextureLoader();
			var waterNormals = loader.load('js/ocean/waternormals.jpg');
			//var waterNormals = new THREE.ImageUtils.loadTexture('js/ocean/waternormals.jpg')
			waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping; 
			var ms_Water = new THREE.Water(renderer, camera, scene, {
				textureWidth: 256,
				textureHeight: 256,
				waterNormals: waterNormals,
				alpha: 	1.0,
				sunDirection: directionalLight.position.normalize(),
				sunColor: 0xffffff,
				waterColor: 0x001e0f,
				betaVersion: 0,
				side: THREE.DoubleSide
			});
			var aMeshMirror = new THREE.Mesh(
				new THREE.PlaneBufferGeometry(2, 2, 10, 10), 
				ms_Water.material.texture
			);
			aMeshMirror.add(ms_Water);
			 
			aMeshMirror.rotation.x = - Math.PI * 0.5;	
			aMeshMirror.position.y = -3.0;	
			scene.add(aMeshMirror);
			// For some reason water rendering does not work

			// Add text
			// var text = new THREEx.Text('Hello');
			// scene.add(text);
			// TODO Adding text with the imported THREEx library does not work

			function createBlockObjectRow(row, offset){
				var rowObjects = [false, false, false, false, false, false];
				for (var i = 0; i < blockArrayWidth; i++) {
					if (row[i] == true) {
						var blockGeo = new THREE.BoxGeometry(blockDistance, blockDistance, blockDistance);
						var blockMat = new THREE.MeshBasicMaterial({color: 0x994422});
						var blockObj = new THREE.Mesh(blockGeo, blockMat);
						blockObj.position.x = blockDistance * i - blockDistance * 3;
						blockObj.position.y = playerInitialY - blockDistance;
						blockObj.position.z = -offset;
						rowObjects[i] = blockObj;
						scene.add(blockObj);
					}
				}
				return rowObjects;
			}

			function removeBlockObjectRow(row){
				for (var i = 0; i < blockArrayWidth; i++) {
					if (row[i] != false) {
						scene.remove(row[i]);
					}
				}
			}

			function createRow(){
				newRow = [false, false, false, false, false, false];
				newRouteIndex = lastRouteBlockIndex + (2 * Math.round(Math.random()) - 1);
				if (newRouteIndex > BLOCK_ARRAY_LAST_INDEX) {
					newRouteIndex = BLOCK_ARRAY_LAST_INDEX - 1;
				}
				if (newRouteIndex < 0) {
					newRouteIndex = 1;
				}
				newRow[newRouteIndex] = true;
				for (var i = 0; i < blockArrayWidth; i++) {
					if (Math.random() > 0.8) {
						newRow[i] = true;
					}
				}
				lastRouteBlockIndex = newRouteIndex;
				return newRow;
			}

			// Create game loop that is executed 50 times per second
			var gameloop = new THREEx.PhysicsLoop(50);

			function handleInput(delta){
				//console.log('Handling input');
				if (action.localeCompare("") == 0) // Is equal to
				{
					console.log('Handling input');
					if (keyboard.pressed("left"))
					{
						action = "JumpLeft";
						console.log('Left pressed!');
						actionDuration = jumpDuration;
					}
					if (keyboard.pressed("right"))
					{
						action = "JumpRight";
						console.log('Right pressed!');
						actionDuration = jumpDuration;
					}
				}
			}

			function alterState(delta){
				ms_Water.material.uniforms.time.value += 1.0 / 50.0;
				//console.log('Altering game state');
				if (action.localeCompare("") != 0) // Not equal to
				{
					if (action.localeCompare("JumpLeft") == 0)
					{
						if (playerPositionIndexX > 0 && playerPositionIndexY < blockArrayLength - 1)
						{
							player.position.x -= blockDistance / jumpDuration;
							player.position.z -= blockDistance / jumpDuration;
							var x = 1.0 - actionDuration / jumpDuration;
							var jump_pos = -4.0 * x * x + 4 * x;		
							player.position.y = playerInitialY + jump_pos * jump_height;
							actionDuration -= 1;

							if (actionDuration == 0)
							{
								playerPositionIndexX -= 1;
								playerPositionIndexY += 1;
								// TODO Handle "death" if there is no log in this cell
							}
						}
						else
						{
							actionDuration = 0;
						}
					}
					else if (action.localeCompare("JumpRight") == 0)
					{
						if (playerPositionIndexX < blockArrayWidth - 1 && playerPositionIndexY < blockArrayLength - 1)
						{
							player.position.x += blockDistance / jumpDuration; // Move left
							player.position.z -= blockDistance / jumpDuration; // Move forward
							var x = 1.0 - actionDuration / jumpDuration;
							var jump_pos = -4.0 * x * x + 4 * x;		
							player.position.y = playerInitialY + jump_pos * jump_height;

							actionDuration -= 1;

							if (actionDuration == 0)
							{
								playerPositionIndexX += 1;
								playerPositionIndexY += 1;
								// TODO Handle "death" if there is no log in this cell
							}
						}
						else
						{
							actionDuration = 0;
						}
					}
				}

				if (actionDuration == 0)
				{
					action = "";
				}

				// Move logs and player downwards in the stream
				player.position.z += flowSpeed;
				nextSpawnIn -= flowSpeed;

				for (var row = 1; row < blockArrayLength; row++) {
					for (var pos = 0; pos < blockArrayWidth; pos++) {
						if (blockObjects[row][pos] != false) {
							blockObjects[row][pos].position.z += flowSpeed;
						}
					}
				}

				// If its time to destroy last row and add a new one
				if (nextSpawnIn <= 0.0)
				{
					// Remove the first row of blocks and add a new one to the end
					removeBlockObjectRow(blocks[0]);
					blockObjects.shift();
					blocks.shift();

					var new_row = createRow();
					blocks.push(new_row);
					blockObjects.push(createBlockObjectRow(new_row, blockArrayLength - 1));
					console.log(new_row);

					nextSpawnIn = spawnLogsInterval;
				}
			}

			gameloop.add(handleInput);
			gameloop.add(alterState);

			// Create loop that is executed after each render
			var renderingloop = new THREEx.RenderingLoop();
			function function2(delta){
				//console.log('Rendering loop call');
			}

			renderingloop.add(function2);

			camera.position.z = 5;

			// Render loop
			function render() {
				requestAnimationFrame( render );
				ms_Water.render();
				renderer.render( scene, camera );
			}
			
			// Start loops
			gameloop.start();
			renderingloop.start();

			render();
		</script>
	</body>
</html>